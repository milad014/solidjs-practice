"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const analyze_1 = require("./analyze");
const rule = {
    meta: {
        type: "problem",
        docs: {
            recommended: "warn",
            description: "Enforce that reactive expressions (props, signals, memos, etc.) are only used in tracked scopes; otherwise, they won't update the view as expected.",
            url: "https://github.com/solidjs-community/eslint-plugin-solid/blob/main/docs/reactivity.md",
        },
        schema: [],
        messages: {
            noWrite: "The reactive variable '{{name}}' should not be reassigned or altered directly.",
            untrackedReactive: "The reactive variable '{{name}}' should be used within JSX, a tracked scope (like createEffect), or inside an event handler function.",
            expectedFunctionGotExpression: "The reactive variable '{{name}}' should be wrapped in a function for reactivity. This includes event handler bindings on native elements, which are not reactive like other JSX props.",
            badSignal: "The reactive variable '{{name}}' should be called as a function when used in {{where}}.",
            badUnnamedDerivedSignal: "This function should be passed to a tracked scope (like createEffect) or an event handler because it contains reactivity.",
            shouldDestructure: "For proper analysis, array destructuring should be used to capture the {{nth}}result of this function call.",
            shouldAssign: "For proper analysis, a variable should be used to capture the result of this function call.",
            noAsyncTrackedScope: "This tracked scope should not be async. Solid's reactivity only tracks synchronously.",
        },
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        const { handleImportDeclaration, matchImport, matchLocalToModule } = (0, utils_1.trackImports)(/^/);
        const root = new analyze_1.ReactivityScope(sourceCode.ast, null);
        const syncCallbacks = new Set();
        const undistributedReferences = [];
        let currentScope = root;
        function onFunctionEnter(node) {
            const childScope = new analyze_1.ReactivityScope(node, currentScope);
            currentScope.childScopes.push(childScope);
            currentScope = childScope;
        }
        function onJSX() {
            currentScope.hasJSX = true;
        }
        function onFunctionExit() {
            currentScope = currentScope.parentScope;
        }
        function stripSyncCallbacks(root) {
            for (const scope of root.walk()) {
                if (scope.childScopes.length > 0) {
                    const addedChildScopes = [];
                    scope.childScopes = scope.childScopes.filter((childScope) => {
                        if ((0, utils_1.isFunctionNode)(childScope.node) && syncCallbacks.has(childScope.node)) {
                            addedChildScopes.push(...childScope.childScopes);
                            scope.trackedScopes.push(...childScope.trackedScopes);
                            scope.references.push(...childScope.references);
                            scope.hasJSX = scope.hasJSX || childScope.hasJSX;
                            return false;
                        }
                        return true;
                    });
                    scope.childScopes.push(...addedChildScopes);
                }
            }
        }
        function getReferences(node, path) {
            var _a;
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "VariableDeclarator" && node.parent.init === node) {
            }
        }
        function distributeReferences(root, references) {
            references.forEach((ref) => {
                const range = "range" in ref.reference ? ref.reference.range : ref.reference.identifier.range;
                const scope = root.deepestScopeContaining(range);
                scope.references.push(ref);
            });
        }
        const pluginApi = {
            calledFunction(node) {
                currentScope.trackedScopes.push({ node, expect: "called-function" });
            },
            trackedScope(node) {
                currentScope.trackedScopes.push({ node, expect: "tracked-scope" });
            },
            syncCallback(node) {
                syncCallbacks.add(node);
            },
            provideErrorContext(node) {
                currentScope.errorContexts.push(node);
            },
            signal(node, path) {
                const references = [];
                undistributedReferences.push(...references);
            },
            store(node, path, options) {
                const references = [];
                undistributedReferences.push(...references);
            },
            reactive(node, path) {
                const references = [];
                undistributedReferences.push(...references);
            },
            isCall(node, primitive) {
                return (node.type === "CallExpression" &&
                    (!primitive || (node.callee.type === "Identifier" && node.callee.name === primitive)));
            },
        };
        const visitors = [];
        return {
            FunctionExpression: onFunctionEnter,
            ArrowFunctionExpression: onFunctionEnter,
            FunctionDeclaration: onFunctionEnter,
            "FunctionExpression:exit": onFunctionExit,
            "ArrowFunctionExpression:exit": onFunctionExit,
            "FunctionDeclaration:exit": onFunctionExit,
            JSXElement: onJSX,
            JSXFragment: onJSX,
            ImportDeclaration: handleImportDeclaration,
            "*"(node) {
                visitors.forEach((visitor) => { var _a; return (_a = visitor[node.type]) === null || _a === void 0 ? void 0 : _a.call(visitor, node); });
            },
            "Program:exit"() {
                stripSyncCallbacks(root);
                distributeReferences(root, undistributedReferences);
                analyze(root);
            },
        };
    },
};
