{"version":3,"file":"index.module.js","sources":["../../src/abstract-control.ts","../../src/abstract-control-container.ts","../../src/util.ts","../../src/abstract-control-base.ts","../../src/form-control.ts","../../src/abstract-control-container-base.ts","../../src/form-group.ts","../../src/form-array.ts"],"sourcesContent":["// *****************************\n// Misc Types\n// *****************************\n\nexport type ControlId = string | symbol;\n\nexport type ValidatorFn<T = any> = (rawValue: T) => ValidationErrors | null;\n\nexport interface ValidationErrors {\n  [key: string]: any;\n}\n\n// *****************************\n// AbstractControl interface\n// *****************************\n\nexport const AbstractControlInterface = '@@AbstractControlInterface_solidjs';\n\n/** Returns true if the provided object implements `IAbstractControl` */\nexport function isAbstractControl(\n  object?: unknown\n): object is IAbstractControl {\n  return (\n    typeof object === 'object' &&\n    (object as any)?.[AbstractControlInterface] === true\n  );\n}\n\nexport interface IAbstractControl<\n  RawValue = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n> {\n  /**\n   * The ID is used to determine where StateChanges originated,\n   * and to ensure that a given AbstractControl only processes\n   * values one time.\n   */\n  readonly id: ControlId;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  readonly data: Data;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue`.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly value: Value;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue` and\n   * rawValue just contains the control's value.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly rawValue: RawValue;\n\n  /**\n   * `true` if this control is disabled, false otherwise.\n   * This is an alias for `self.isDisabled`.\n   */\n  readonly isDisabled: boolean;\n\n  /**\n   * `true` if this control is touched, false otherwise.\n   * This is an alias for `self.isTouched`.\n   */\n  readonly isTouched: boolean;\n\n  /**\n   * `true` if this control is dirty, false otherwise.\n   * This is an alias for `self.isDirty`.\n   */\n  readonly isDirty: boolean;\n  /**\n   * `true` if this control is readonly, false otherwise.\n   * This is an alias for `self.isReadonly`.\n   */\n  readonly isReadonly: boolean;\n  /**\n   * `true` if this control is submitted, false otherwise.\n   * This is an alias for `self.isSubmitted`.\n   */\n  readonly isSubmitted: boolean;\n  /**\n   * `true` if this control is required, false otherwise.\n   * This is an alias for `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()`, you could choose to alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  readonly isRequired: boolean;\n\n  /**\n   * Contains a `ValidationErrors` object if this control\n   * has any errors. Otherwise contains `null`.\n   *\n   * An alias for `self.errors`.\n   */\n  readonly errors: ValidationErrors | null;\n\n  /**\n   * A validator function that is run on rawValue changes and which\n   * generates errors associated with the source \"CONTROL_DEFAULT_SOURCE\".\n   */\n  readonly validator: ValidatorFn | null;\n\n  /**\n   * `true` if this control is pending, false otherwise.\n   * This is an alias for `self.isPending`.\n   */\n  readonly isPending: boolean;\n\n  /**\n   * Valid if `errors === null && !isPending`\n   *\n   * This is an alias for `self.valid`.\n   */\n  readonly isValid: boolean;\n\n  /**\n   * The `self` object on an abstract control contains\n   * properties reflecting the control's personal state. On an\n   * IAbstractControlContainer, the personal state can differ\n   * from the control's state. For example, an\n   * IAbstractControlContainer will register as disabled if\n   * the control itself has been marked as disabled OR if\n   * all of it's child controls are disabled.\n   *\n   * Marking the control container\n   * itself as disabled doesn't mark the container's children as\n   * disabled. On a standard IAbstractControl though,\n   * the \"self\" properties are the same as regular properties.\n   * I.e. `self.isInvalid` is the same as `isInvalid` on a\n   * standard IAbstractControl (actually, `isInvalid` is\n   * an alias for `self.isInvalid` on a standard control).\n   */\n  readonly self: {\n    /** `this.self.errors === null && !this.self.isPending` */\n    readonly isValid: boolean;\n\n    /** `true` if this control is disabled, false otherwise. */\n    readonly isDisabled: boolean;\n\n    /** `true` if this control is touched, false otherwise. */\n    readonly isTouched: boolean;\n\n    /**\n     * `true` if this control is dirty, false otherwise.\n     *\n     * Dirty can be thought of as, \"Has the value changed?\"\n     * Though the isDirty property must be manually set by\n     * the user (using `markDirty()`) and is not automatically\n     * updated.\n     */\n    readonly isDirty: boolean;\n    /**\n     * `true` if this control is readonly, false otherwise.\n     *\n     * This property does not have any predefined meeting for\n     * an IAbstractControl. You can decide if you want to give\n     * it meaning by, for example, using this value to set\n     * an input's readonly status (e.g.\n     * `<input readonly={control.isReadonly} />`)\n     */\n    readonly isReadonly: boolean;\n\n    /** `true` if this control is submitted, false otherwise. */\n    readonly isSubmitted: boolean;\n\n    /**\n     * `true` if this control is required, false otherwise.\n     *\n     * Note that this property doesn't\n     * have any predefined meaning for IAbstractControls and it doesn't affect\n     * validation in any way. It is up to you to decide what meaning, if any,\n     * to give to this property and how to use it. For example, if you\n     * validated the control inside a `createEffect()` you could alter the\n     * validation based on whether the control was marked as `required` or\n     * not.\n     */\n    readonly isRequired: boolean;\n\n    /** `true` if this control is pending, false otherwise. */\n    readonly isPending: boolean;\n\n    /**\n     * Contains a `ValidationErrors` object if this control\n     * has any errors. Otherwise contains `null`.\n     */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * *More advanced-ish*\n     *\n     * Contains a map of ControlId values and ValidationErrors.\n     * The errorsStore allows partitioning errors so that\n     * they can be associated with different sources and so\n     * that one source does not overwrite another source.\n     *\n     * The `self.errors` property gets its errors from the errorsStore.\n     */\n    readonly errorsStore: ReadonlyMap<ControlId, ValidationErrors>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A set of ControlIds. `self.isPending` is true so long\n     * as `pendingStore.size > 0`. Because this is a set, you\n     * can track multiple pending \"things\" at once. This\n     * control will register as pending until all of the \"things\"\n     * have resolved. Use the `markPending()` method with\n     * the `source` option to update the pendingStore.\n     */\n    readonly pendingStore: ReadonlySet<ControlId>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A map of ControlIds and ValidatorFns. The `validator`\n     * property is composed of all the validator functions in the\n     * `validatorStore`. The validatorStore allows you to change\n     * individual validator functions on the control without\n     * affecting other validator functions on the control.\n     *\n     * When you use the `setValidators` method, you are updating\n     * the validatorStore.\n     */\n    readonly validatorStore: ReadonlyMap<ControlId, ValidatorFn>;\n  };\n\n  /**\n   * If this control is disabled, the status is `\"DISABLED\"`,\n   * else if this control is pending, the status is `\"PENDING\"`,\n   * else if this control has any errors, the status is `\"INVALID\"`,\n   * else the status is `\"VALID\"`.\n   */\n  readonly status: 'DISABLED' | 'PENDING' | 'INVALID' | 'VALID';\n\n  [AbstractControlInterface]: true;\n\n  /** set the control's value  */\n  setValue(value: RawValue): void;\n\n  /**\n   * If provided a `ValidationErrors` object or `null`, replaces `self.errors`.\n   * Optionally, provide a source ID and the change will be partitioned\n   * assocaited with the source ID. The default source ID is\n   * \"CONTROL_DEFAULT_SOURCE\".\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that will replace the `self.errorsStore` associated with this control.\n   */\n  setErrors(\n    value: ValidationErrors | null | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * If you provide a `ValidationErrors` object, that object is merged with the\n   * existing errors associated with the source ID. If the error object has\n   * keys equal to `null`, errors associated with those keys are deleted\n   * from the errors object.\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that object is merged with the existing `errorsStore`.\n   */\n  patchErrors(\n    value: ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `self.isTouched` */\n  markTouched(value: boolean): void;\n\n  /** sets `self.isDirty` */\n  markDirty(value: boolean): void;\n\n  /** sets `self.isReadonly` */\n  markReadonly(value: boolean): void;\n\n  /**\n   * Sets `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()` you could alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  markRequired(value: boolean): void;\n\n  /**\n   * Set `self.isDisabled`.\n   *\n   * Note that `self.isDisabled`` affect's the control's `status`\n   * property. Additionally, `IAbstractControlContainer's` ignore\n   * disabled children in many cases. For example, the `value` of a\n   * control container is equal to the value of it's _enabled_ children\n   * (if you want to see the value including disabled children, use\n   * `rawValue`).\n   */\n  markDisabled(value: boolean): void;\n\n  /** sets `self.isSubmitted` */\n  markSubmitted(value: boolean): void;\n\n  /** sets `self.pendingStore` and `self.isPending` */\n  markPending(\n    value: boolean | ReadonlySet<ControlId>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `validator` and `self.validatorStore` */\n  setValidators(\n    value:\n      | ValidatorFn\n      | ValidatorFn[]\n      | ReadonlyMap<ControlId, ValidatorFn>\n      | null,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  setData<K extends keyof Data>(key: K, data: Data[K]): void;\n}\n","import {\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\n\n// UTILITY TYPES\n\ntype PickUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\ntype PickRequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\ntype ObjectControlsOptionalRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<\n    T[P]\n  >['rawValue'];\n};\n\ntype ObjectControlsRequiredRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['rawValue'];\n};\n\ntype ArrayControlsRawValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['rawValue']>\n      : never\n    : never;\n\ntype ObjectControlsOptionalValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<T[P]>['value'];\n};\n\ntype ObjectControlsRequiredValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['value'];\n};\n\ntype ArrayControlsValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['value']>\n      : never\n    : never;\n\n// END UTILITY TYPES\n\nexport type GenericControlsObject =\n  | {\n      readonly [key: string]: IAbstractControl;\n    }\n  | ReadonlyArray<IAbstractControl>;\n\n// need to add the `keyof ControlsRawValue<Controls>` as well as\n// `keyof ControlsValue<Controls>` as well as the `keyof Controls` etc\n// because typescript doesn't realize that all three are the same keys\n// and without all three, then ControlsKey can't be used to index all three\nexport type ControlsKey<Controls extends GenericControlsObject> =\n  keyof ControlsRawValue<Controls> &\n    keyof ControlsValue<Controls> &\n    (Controls extends ReadonlyArray<any>\n      ? keyof Controls & number\n      : Controls extends object\n      ? // the `& string` is needed or else\n        // ControlsKey<{[key: string]: AbstractControl}> is type string | number\n        keyof Controls & string\n      : any);\n\nexport type ControlsRawValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsRawValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? ObjectControlsRequiredRawValue<Controls> &\n        ObjectControlsOptionalRawValue<Controls>\n    : never;\n\nexport type ControlsValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? Partial<\n        ObjectControlsRequiredValue<Controls> &\n          ObjectControlsOptionalValue<Controls>\n      >\n    : never;\n\nexport type ContainerControls<C> = C extends IAbstractControlContainer<\n  infer Controls\n>\n  ? Controls\n  : unknown;\n\nexport const AbstractControlContainerInterface =\n  '@@AbstractControlContainerInterface_solidjs';\n\n/**\n * Returns true if the provided object implements\n * `IAbstractControlContainer`\n */\nexport function isAbstractControlContainer(\n  object?: unknown\n): object is IAbstractControlContainer {\n  return (\n    isAbstractControl(object) &&\n    (object as any)[AbstractControlContainerInterface]\n  );\n}\n\nexport interface IAbstractControlContainer<\n  Controls extends GenericControlsObject = any,\n  Data = any\n> extends IAbstractControl<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  > {\n  /** Child controls associated with this container */\n  readonly controls: Controls;\n\n  /** The number of controls associated with this container */\n  readonly size: number;\n\n  /** Only returns values for enabled child controls. */\n  readonly value: ControlsValue<Controls>;\n\n  /**\n   * Returns values for both enabled and disabled child controls.\n   */\n  readonly rawValue: ControlsRawValue<Controls>;\n\n  /** Will return true if `this.self.isValid` and `this.children.areValid` */\n  readonly isValid: boolean;\n\n  /** Will return true if `this.self.isDisabled` or `this.children.areDisabled` */\n  readonly isDisabled: boolean;\n\n  /** Will return true if `this.self.isReadonly` or `this.children.areReadonly` */\n  readonly isReadonly: boolean;\n\n  /** Will return true if `this.self.isRequired` or `this.child.isRequired` */\n  readonly isRequired: boolean;\n\n  /** Will return true if `this.self.isPending` or `this.child.isPending` */\n  readonly isPending: boolean;\n\n  /** Will return true if `this.self.isTouched` or `this.child.isTouched` */\n  readonly isTouched: boolean;\n\n  /** Will return true if `this.self.isDirty` or `this.child.isDirty` */\n  readonly isDirty: boolean;\n\n  /** Will return true if `this.self.isSubmitted` or `this.children.areSubmitted` */\n  readonly isSubmitted: boolean;\n\n  /** Contains `{ ...this.children.errors, ...this.self.errors }` or `null` if there are none */\n  readonly errors: ValidationErrors | null;\n\n  readonly child: {\n    /** Will return true if *any* `enabled` direct child control is `valid` */\n    readonly isValid: boolean;\n    /** Will return true if *any* direct child control is `disabled` */\n    readonly isDisabled: boolean;\n    /** Will return true if *any* `enabled` direct child control is `readonly` */\n    readonly isReadonly: boolean;\n    /** Will return true if *any* `enabled` direct child control is `required` */\n    readonly isRequired: boolean;\n    /** Will return true if *any* `enabled` direct child control is `pending` */\n    readonly isPending: boolean;\n    /** Will return true if *any* `enabled` direct child control is `touched` */\n    readonly isTouched: boolean;\n    /** Will return true if *any* `enabled` direct child control is `dirty` */\n    readonly isDirty: boolean;\n    /** Will return true if *any* `enabled` direct child control is `submitted` */\n    readonly isSubmitted: boolean;\n  };\n\n  readonly children: {\n    /** Will return true if *all* `enabled` direct child control's are `valid` */\n    readonly areValid: boolean;\n    /** Will return true if *all* direct child control's are `disabled` */\n    readonly areDisabled: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `readonly` */\n    readonly areReadonly: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `required` */\n    readonly areRequired: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `pending` */\n    readonly arePending: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `touched` */\n    readonly areTouched: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `dirty` */\n    readonly areDirty: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `submitted` */\n    readonly areSubmitted: boolean;\n    /** Contains *all* `enabled` child control errors or `null` if there are none */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * Mark all direct children as disabled. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as disabled.\n     */\n    markDisabled(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as touched. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as touched.\n     */\n    markTouched(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as dirty. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as dirty.\n     */\n    markDirty(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as readonly. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as readonly.\n     */\n    markReadonly(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as required. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as required.\n     */\n    markRequired(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as submitted. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as submitted.\n     */\n    markSubmitted(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as pending. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as pending.\n     */\n    markPending(\n      value: boolean,\n      options?: { source?: ControlId; deep?: boolean }\n    ): void;\n  };\n\n  [AbstractControlContainerInterface]: true;\n\n  /**\n   * Apply a partial update to the values of some children but\n   * not all.\n   */\n  patchValue(value: unknown): void;\n\n  /** sets the `controls` property */\n  setControls(controls: Controls): void;\n\n  /** stores the provided control in `controls[key]` */\n  setControl(key: unknown, control: unknown): void;\n\n  /**\n   * If provided a control value, removes the given control from\n   * `controls`. If provided a control key value, removes the\n   * control associated with the given key from `controls`.\n   */\n  removeControl(keyOrControl: unknown): void;\n}\n","import _isEqual from 'fast-deep-equal/es6';\nimport { getOwner, runWithOwner } from 'solid-js';\nimport type { Merge } from 'type-fest';\n\nexport function isEqual<T>(a: T, b: any): b is T {\n  return _isEqual(a, b);\n}\n\nexport function mergeObj<A, B>(a: A, b: Merge<Partial<A>, B>): Merge<A, B> {\n  return Object.defineProperties(\n    a,\n    Object.getOwnPropertyDescriptors(b)\n  ) as unknown as Merge<A, B>;\n}\n\n/**\n * Helper to bind the owner of the current context to the\n * supplied function.\n *\n * Implementation is very simple:\n * ```ts\n * import { getOwner, runWithOwner } from 'solid-js';\n *\n * export function bindOwner<T>(fn: () => T): () => T {\n *   const owner = getOwner();\n *\n *   if (!owner) {\n *     throw new Error('No solidjs owner in current context');\n *   }\n *\n *   return () => runWithOwner(owner, fn);\n * }\n * ```\n */\nexport function bindOwner<T>(fn: () => T): () => T {\n  const owner = getOwner();\n\n  if (!owner) {\n    throw new Error('No solidjs owner in current context');\n  }\n\n  return () => runWithOwner(owner, fn);\n}\n","import type {\n  ValidatorFn,\n  ValidationErrors,\n  ControlId,\n  AbstractControlInterface,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  Accessor,\n  createComputed,\n  createMemo,\n  createSignal,\n  on,\n} from 'solid-js';\nimport { isEqual } from './util';\n\nexport const DEFAULT_SOURCE = 'CONTROL_DEFAULT_SOURCE';\n\nexport interface IAbstractControlBaseOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> {\n  id?: ControlId;\n  data?: Data;\n  disabled?: boolean;\n  touched?: boolean;\n  dirty?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  submitted?: boolean;\n  errors?: null | ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>;\n  validators?:\n    | null\n    | ValidatorFn\n    | ValidatorFn[]\n    | ReadonlyMap<ControlId, ValidatorFn>;\n  pending?: boolean | ReadonlySet<ControlId>;\n}\n\nexport function propInitializer(): [\n  propInitializing: <T>(value: T) => T,\n  initComplete: () => void\n] {\n  const [initializationSignal, setInitializationSignal] = createSignal<\n    null | false\n  >(null);\n\n  return [\n    <T>(value: T) => initializationSignal() || value,\n    () => setInitializationSignal(false),\n  ];\n}\n\nexport function composeValidators(\n  validators: undefined | null | ValidatorFn | ValidatorFn[]\n): null | ValidatorFn {\n  if (!validators || (Array.isArray(validators) && validators.length === 0)) {\n    return null;\n  }\n\n  if (Array.isArray(validators)) {\n    return (control) =>\n      validators.reduce((prev: ValidationErrors | null, curr: ValidatorFn) => {\n        const errors = curr(control);\n        return errors ? { ...prev, ...errors } : prev;\n      }, null);\n  }\n\n  return validators;\n}\n\nexport type IAbstractControlBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> = Omit<\n  IAbstractControl<unknown, Data, unknown>,\n  'value' | 'rawValue' | 'setValue' | typeof AbstractControlInterface\n>;\n\nlet controlId = 0;\n\nexport function createAbstractControlBase<\n  RawValue,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControl<RawValue, Data, Value>>,\n      SetStoreFunction<IAbstractControl<RawValue, Data, Value>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: Pick<IAbstractControlBaseOptions<Data>, 'id' | 'data'> = {}\n): [base: IAbstractControlBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControl<RawValue, Data, Value>>;\n  let setControl: SetStoreFunction<IAbstractControl<RawValue, Data, Value>>;\n\n  let selfIsPendingMemo: Accessor<IAbstractControl['self']['isPending']>;\n  let selfErrorsMemo: Accessor<ValidationErrors | null>;\n  let statusMemo: Accessor<IAbstractControl['status']>;\n  let validatorMemo: Accessor<IAbstractControl['validator']>;\n\n  const base: IAbstractControlBase<Data> = {\n    id: initOptions.id || Symbol(`AbstractControl-${controlId++}`),\n\n    data: { ...(initOptions.data as Data) },\n\n    self: {\n      get isValid() {\n        // here \"this\" is self\n        return this.errors === null && !this.isPending;\n      },\n      isDisabled: false,\n      isTouched: false,\n      isDirty: false,\n      isReadonly: false,\n      isSubmitted: false,\n      isRequired: false,\n      get isPending() {\n        return selfIsPendingMemo?.() ?? untilInit(false);\n      },\n      get errors() {\n        return selfErrorsMemo?.() ?? untilInit(null);\n      },\n      errorsStore: new Map(),\n      pendingStore: new Set(),\n      validatorStore: new Map(),\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired;\n    },\n\n    get errors() {\n      return this.self.errors;\n    },\n\n    get isPending() {\n      return this.self.isPending;\n    },\n\n    get isValid() {\n      return this.self.isValid;\n    },\n\n    get status() {\n      return statusMemo?.() ?? untilInit('VALID');\n    },\n\n    get validator() {\n      return validatorMemo?.() ?? untilInit(null);\n    },\n\n    markDisabled(input) {\n      if (isEqual(this.self.isDisabled, input)) return;\n      setControl('self', 'isDisabled', input);\n    },\n\n    markReadonly(input) {\n      if (isEqual(this.self.isReadonly, input)) return;\n      setControl('self', 'isReadonly', input);\n    },\n\n    markRequired(input) {\n      if (isEqual(this.self.isRequired, input)) return;\n      setControl('self', 'isRequired', input);\n    },\n\n    markDirty(input) {\n      if (isEqual(this.self.isDirty, input)) return;\n      setControl('self', 'isDirty', input);\n    },\n\n    markTouched(input) {\n      if (isEqual(this.self.isTouched, input)) return;\n      setControl('self', 'isTouched', input);\n    },\n\n    markSubmitted(input) {\n      if (isEqual(this.self.isSubmitted, input)) return;\n      setControl('self', 'isSubmitted', input);\n    },\n\n    markPending(input, options) {\n      let newPendingStore: Set<ControlId>;\n\n      if (typeof input === 'boolean') {\n        const source = options?.source || DEFAULT_SOURCE;\n\n        if (this.self.pendingStore.has(source) === input) return;\n\n        newPendingStore = new Set(this.self.pendingStore);\n\n        if (input) {\n          newPendingStore.add(source);\n        } else {\n          newPendingStore.delete(source);\n        }\n      } else {\n        if (this.self.pendingStore === input) return;\n\n        newPendingStore = new Set(input);\n      }\n\n      if (isEqual(this.self.pendingStore, newPendingStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.pendingStore as Set<ControlId>) = newPendingStore;\n        })\n      );\n    },\n\n    setErrors(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      const existingStore = this.self.errorsStore;\n\n      let newErrorsStore: Map<ControlId, ValidationErrors>;\n\n      if (input instanceof Map) {\n        newErrorsStore = input;\n      } else if (input === null || Object.keys(input).length === 0) {\n        newErrorsStore = new Map(existingStore);\n        newErrorsStore.delete(source);\n      } else {\n        newErrorsStore = new Map(existingStore).set(source, input);\n      }\n\n      if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n            newErrorsStore;\n        })\n      );\n    },\n\n    patchErrors(input, options) {\n      const existingStore = this.self.errorsStore as Map<\n        ControlId,\n        ValidationErrors\n      >;\n\n      if (input instanceof Map) {\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              new Map([...existingStore, ...input]);\n          })\n        );\n      } else {\n        if (Object.keys(input).length === 0) return;\n\n        const source = options?.source || DEFAULT_SOURCE;\n\n        let newErrors: ValidationErrors = input;\n\n        let existingValue = existingStore.get(source);\n\n        if (existingValue) {\n          existingValue = { ...existingValue };\n\n          for (const [k, err] of Object.entries(newErrors)) {\n            if (err === null) {\n              delete existingValue![k];\n            } else {\n              existingValue![k] = err;\n            }\n          }\n\n          newErrors = existingValue;\n        } else {\n          const entries = Object.entries(newErrors).filter(\n            ([, v]) => v !== null\n          );\n\n          if (entries.length === 0) return;\n\n          newErrors = Object.fromEntries(entries);\n        }\n\n        const newErrorsStore = new Map(existingStore);\n\n        if (Object.keys(newErrors).length === 0) {\n          newErrorsStore.delete(source);\n        } else {\n          newErrorsStore.set(source, newErrors);\n        }\n\n        if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              newErrorsStore;\n          })\n        );\n      }\n    },\n\n    setValidators(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      let newValidatorsStore: Map<ControlId, ValidatorFn>;\n\n      if (input instanceof Map) {\n        newValidatorsStore = new Map(input);\n      } else {\n        newValidatorsStore = new Map(\n          this.self.validatorStore as Map<ControlId, ValidatorFn>\n        );\n\n        const newValidator = composeValidators(\n          input as Exclude<typeof input, ReadonlyMap<any, any>>\n        );\n\n        if (newValidator) {\n          newValidatorsStore.set(source, newValidator);\n        } else {\n          newValidatorsStore.delete(source);\n        }\n      }\n\n      if (isEqual(this.self.validatorStore, newValidatorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.validatorStore as Map<ControlId, ValidatorFn<any>>) =\n            newValidatorsStore;\n        })\n      );\n    },\n\n    setData(key, input) {\n      if (isEqual(this.data[key], input)) return;\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          state.data[key] = input;\n        })\n      );\n    },\n  };\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    selfIsPendingMemo = createMemo(() => control.self.pendingStore.size > 0);\n\n    selfErrorsMemo = createMemo(() => {\n      return control.self.errorsStore.size === 0\n        ? null\n        : Array.from(\n            control.self.errorsStore.values()\n          ).reduce<ValidationErrors>(\n            (p, errors) => ({\n              ...p,\n              ...errors,\n            }),\n            {}\n          );\n    });\n\n    statusMemo = createMemo(() => {\n      return control.isDisabled\n        ? 'DISABLED'\n        : control.isPending\n        ? 'PENDING'\n        : control.isValid\n        ? 'VALID'\n        : 'INVALID';\n    });\n\n    validatorMemo = createMemo(() => {\n      if (control.self.validatorStore.size === 0) return null;\n\n      const validators = Array.from(control.self.validatorStore.values());\n\n      return (c) => {\n        const e = validators.reduce<ValidationErrors>((err, v) => {\n          return { ...err, ...v(c) };\n        }, {});\n\n        return Object.keys(e).length === 0 ? null : e;\n      };\n    });\n\n    // Intentionally not using `createRenderEffect()` since it appears to\n    // mess with initializing a control with errors (i.e. it clears the errors\n    // after the control is initialized)\n    createComputed(\n      on(\n        () => control.validator?.(control.rawValue) ?? null,\n        (errors) => {\n          if (control.self.errorsStore.get(DEFAULT_SOURCE) === errors) return;\n\n          const newErrorsStore = new Map(\n            control.self.errorsStore as Map<ControlId, ValidationErrors>\n          );\n\n          if (errors) {\n            newErrorsStore.set(DEFAULT_SOURCE, errors);\n          } else {\n            newErrorsStore.delete(DEFAULT_SOURCE);\n          }\n\n          if (isEqual(control.self.errorsStore, newErrorsStore)) return;\n\n          // We're using `produce()` here because using the standard solid Store\n          // nested setter has some bugs (i.e.\n          // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n          // bugs are isolated to object values, so, at the moment, I'm only using\n          // produce where the value is an object.\n          setControl(\n            produce((state) => {\n              (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n                newErrorsStore;\n            })\n          );\n        }\n      )\n    );\n  };\n\n  return [base, initializer];\n}\n","import { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  IAbstractControl,\n  ControlId,\n  AbstractControlInterface,\n  isAbstractControl,\n} from './abstract-control';\nimport {\n  IAbstractControlBaseOptions,\n  createAbstractControlBase,\n  propInitializer,\n} from './abstract-control-base';\nimport { isEqual, mergeObj } from './util';\n\nexport const FormControlInterface = '@@FormControlInterface_solidjs';\n\nexport interface IFormControlOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormControl<\n  Value = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControl<Value, Data, Value> {\n  [FormControlInterface]: true;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormControl`\n */\nexport function isFormControl(object?: unknown): object is IFormControl {\n  return (\n    isAbstractControl(object) &&\n    (object as any)?.[FormControlInterface] === true\n  );\n}\n\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  value?: Value,\n  options?: IFormControlOptions<Data>\n): IFormControl<Value, Data>;\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initValue?: Value,\n  initOptions: IFormControlOptions<Data> = {}\n): IFormControl<Value, Data> {\n  let control: Store<IFormControl<Value, Data>>;\n  let setControl: SetStoreFunction<IFormControl<Value, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlBase<Value, Data, Value>(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [FormControlInterface]: true,\n\n    rawValue: initValue as Value,\n\n    get value() {\n      return this.rawValue;\n    },\n\n    setValue(value) {\n      if (isEqual(this.value, value)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value could be an object.\n      setControl(\n        produce((state) => {\n          (state.rawValue as Value) = value;\n        })\n      );\n    },\n  } as IFormControl<Value, Data>);\n\n  [control, setControl] = createStore<IFormControl<Value, Data>>(storeConfig);\n\n  initializeBase();\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormControl<Value, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\n\nimport { IAbstractControl } from './abstract-control';\n\nimport {\n  AbstractControlContainerInterface,\n  ControlsKey,\n  ControlsRawValue,\n  ControlsValue,\n  GenericControlsObject,\n  isAbstractControlContainer,\n} from './abstract-control-container';\n\nimport { IAbstractControlContainer } from './abstract-control-container';\n\nimport {\n  createAbstractControlBase,\n  IAbstractControlBaseOptions,\n} from './abstract-control-base';\n\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport interface IAbstractControlContainerBaseArgs<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IAbstractControlContainerBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends Omit<\n    IAbstractControlContainer<any, Data>,\n    | 'value'\n    | 'rawValue'\n    | 'controls'\n    | 'setControl'\n    | typeof AbstractControlInterface\n    | typeof AbstractControlContainerInterface\n  > {}\n\nexport function createAbstractControlContainerBase<\n  Controls extends GenericControlsObject = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControlContainer<Controls, Data>>,\n      SetStoreFunction<IAbstractControlContainer<Controls, Data>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: IAbstractControlContainerBaseArgs<Data> = {}\n): [base: IAbstractControlContainerBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControlContainer<Controls, Data>>;\n  let setControl: SetStoreFunction<IAbstractControlContainer<Controls, Data>>;\n\n  const [base, initializeAbstractControl] = createAbstractControlBase<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  >(() => [control, setControl], untilInit, initOptions);\n\n  let sizeMemo: Accessor<number>;\n\n  let childIsValidMemo: Accessor<boolean>;\n  let childIsDisabledMemo: Accessor<boolean>;\n  let childIsReadonlyMemo: Accessor<boolean>;\n  let childIsRequiredMemo: Accessor<boolean>;\n  let childIsPendingMemo: Accessor<boolean>;\n  let childIsTouchedMemo: Accessor<boolean>;\n  let childIsDirtyMemo: Accessor<boolean>;\n  let childIsSubmittedMemo: Accessor<boolean>;\n\n  let childrenAreValidMemo: Accessor<boolean>;\n  let childrenAreDisabledMemo: Accessor<boolean>;\n  let childrenAreReadonlyMemo: Accessor<boolean>;\n  let childrenAreRequiredMemo: Accessor<boolean>;\n  let childrenArePendingMemo: Accessor<boolean>;\n  let childrenAreTouchedMemo: Accessor<boolean>;\n  let childrenAreDirtyMemo: Accessor<boolean>;\n  let childrenAreSubmittedMemo: Accessor<boolean>;\n\n  let errorsMemo: Accessor<ValidationErrors | null>;\n  let childrenErrorsMemo: Accessor<ValidationErrors | null>;\n\n  const containerBase = mergeObj(base, {\n    get size() {\n      return sizeMemo?.() ?? untilInit(0);\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled || this.children.areDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched || this.child.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty || this.child.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly || this.children.areReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted || this.children.areSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired || this.child.isRequired;\n    },\n\n    get isPending() {\n      return this.self.isPending || this.child.isPending;\n    },\n\n    get errors() {\n      return errorsMemo?.() ?? untilInit(null);\n    },\n\n    get isValid() {\n      return this.self.isValid && this.children.areValid;\n    },\n\n    child: {\n      /** Will return true if *any* `enabled` direct child control is `valid` */\n      get isValid() {\n        return childIsValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *any* direct child control is `disabled` */\n      get isDisabled() {\n        return childIsDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `readonly` */\n      get isReadonly() {\n        return childIsReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `required` */\n      get isRequired() {\n        return childIsRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `pending` */\n      get isPending() {\n        return childIsPendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `touched` */\n      get isTouched() {\n        return childIsTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `dirty` */\n      get isDirty() {\n        return childIsDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `submitted` */\n      get isSubmitted() {\n        return childIsSubmittedMemo?.() ?? untilInit(false);\n      },\n    },\n\n    children: {\n      /** Will return true if *all* `enabled` direct child control's are `valid` */\n      get areValid() {\n        return childrenAreValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *all* direct child control's are `disabled` */\n      get areDisabled() {\n        return childrenAreDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `readonly` */\n      get areReadonly() {\n        return childrenAreReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `required` */\n      get areRequired() {\n        return childrenAreRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `pending` */\n      get arePending() {\n        return childrenArePendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `touched` */\n      get areTouched() {\n        return childrenAreTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `dirty` */\n      get areDirty() {\n        return childrenAreDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `submitted` */\n      get areSubmitted() {\n        return childrenAreSubmittedMemo?.() ?? untilInit(false);\n      },\n      /** Contains *all* `enabled` child control errors or `null` if there are none */\n      get errors() {\n        return childrenErrorsMemo?.() ?? untilInit(null);\n      },\n\n      markDirty(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDirty(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDirty(value, options);\n          });\n        });\n      },\n\n      markDisabled(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDisabled(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDisabled(value, options);\n          });\n        });\n      },\n\n      markPending(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markPending(value, options);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markPending(value, options);\n          });\n        });\n      },\n\n      markReadonly(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markReadonly(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markReadonly(value, options);\n          });\n        });\n      },\n\n      markRequired(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markRequired(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markRequired(value, options);\n          });\n        });\n      },\n\n      markSubmitted(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markSubmitted(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markSubmitted(value, options);\n          });\n        });\n      },\n\n      markTouched(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markTouched(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markTouched(value, options);\n          });\n        });\n      },\n    },\n\n    setControls(controls: Controls) {\n      if (isEqual(control.controls, controls)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.controls as Controls) = controls;\n        })\n      );\n    },\n\n    /**\n     * The provided control is removed from this FormGroup\n     * if it is a child of this FormGroup. Or the control\n     * associated with the provided key is removed.\n     */\n    removeControl(\n      keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n    ) {\n      if (!isAbstractControl(keyOrControl)) {\n        control.setControl(keyOrControl as ControlsKey<Controls>, null);\n        return;\n      }\n\n      const childControl = keyOrControl;\n\n      for (const [key, c] of Object.entries(control.controls!)) {\n        if (c !== childControl) continue;\n\n        control.setControl(key as ControlsKey<Controls>, null);\n        return;\n      }\n    },\n\n    setValue(value: ControlsRawValue<Controls>) {\n      const valueEntries = Object.entries(value);\n\n      if (valueEntries.length !== control.size!) {\n        throw new Error(\n          `setValue error: you must provide a value for each control.`\n        );\n      }\n\n      batch(() => {\n        for (const [key, val] of valueEntries) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid setValue value key \"${key}\".`);\n          }\n\n          c.setValue(val);\n        }\n      });\n    },\n\n    patchValue(value: PartialDeep<ControlsRawValue<Controls>>) {\n      batch(() => {\n        for (const [key, entryValue] of Object.entries(value)) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid patchValue value key \"${key}\".`);\n          }\n\n          if (isAbstractControlContainer(c)) {\n            c.patchValue(entryValue);\n          } else {\n            c.setValue(entryValue);\n          }\n        }\n      });\n    },\n  } as IAbstractControlContainerBase<Data>);\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    initializeAbstractControl();\n\n    const allControlsMemo = createMemo(() => Object.values(control.controls));\n\n    const nonDisabledControlsMemo = createMemo(() =>\n      allControlsMemo().filter((c) => !c.isDisabled)\n    );\n\n    sizeMemo = createMemo(() => allControlsMemo().length);\n\n    childIsValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isValid)\n    );\n\n    childIsDisabledMemo = createMemo(() =>\n      allControlsMemo().some((c) => c.isDisabled)\n    );\n\n    childIsReadonlyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isReadonly)\n    );\n\n    childIsRequiredMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isRequired)\n    );\n\n    childIsPendingMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isPending)\n    );\n\n    childIsTouchedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isTouched)\n    );\n\n    childIsDirtyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isDirty)\n    );\n\n    childIsSubmittedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isSubmitted)\n    );\n\n    childrenAreValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().every((c) => c.isValid)\n    );\n\n    childrenAreDisabledMemo = createMemo(() => {\n      const controls = allControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDisabled);\n    });\n\n    childrenAreReadonlyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isReadonly);\n    });\n\n    childrenAreRequiredMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isRequired);\n    });\n\n    childrenArePendingMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isPending);\n    });\n\n    childrenAreTouchedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isTouched);\n    });\n\n    childrenAreDirtyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDirty);\n    });\n\n    childrenAreSubmittedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isSubmitted);\n    });\n\n    errorsMemo = createMemo(() => {\n      if (!control.self.errors && !control.children.errors) return null;\n\n      return {\n        ...control.children.errors,\n        ...control.self.errors,\n      };\n    });\n\n    childrenErrorsMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      return controls.reduce((prev, curr) => {\n        return prev === null && curr.errors === null\n          ? null\n          : { ...prev, ...curr.errors };\n      }, null as ValidationErrors | null);\n    });\n  };\n\n  return [containerBase, initializer];\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormGroupInterface = '@@FormGroupInterface_solidjs';\n\nexport interface IFormGroupOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormGroupInterface]: true;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormGroup`\n */\nexport function isFormGroup(object?: unknown): object is IFormGroup {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormGroupInterface] === true\n  );\n}\n\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormGroupOptions<Data>\n): IFormGroup<Controls, Data>;\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = {} as Controls,\n  initOptions: IFormGroupOptions<Data> = {}\n): IFormGroup<Controls, Data> {\n  let control: Store<IFormGroup<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormGroup<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormGroupInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            delete state.controls[key];\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n  } as IFormGroup<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const allControlEntriesMemo = createMemo(() =>\n    Object.entries(control.controls)\n  );\n\n  const enabledControlEntriesMemo = createMemo(() =>\n    allControlEntriesMemo().filter(([, c]) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        allControlEntriesMemo().map(([k, c]) => [k, c.rawValue])\n      ) as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        enabledControlEntriesMemo().map(([k, c]) => [k, c.value])\n      ) as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormGroup<Controls, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormArrayInterface = '@@FormArrayInterface_solidjs';\n\nexport interface IFormArrayOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormArrayInterface]: true;\n  push(control: Controls[number]): void;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormArray`\n */\nexport function isFormArray(object?: unknown): object is IFormArray {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormArrayInterface] === true\n  );\n}\n\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormArrayOptions<Data>\n): IFormArray<Controls, Data>;\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = [] as unknown as Controls,\n  initOptions: IFormArrayOptions<Data> = {}\n): IFormArray<Controls, Data> {\n  let control: Store<IFormArray<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormArray<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormArrayInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            (\n              state.controls as unknown as Array<\n                typeof state['controls'][number]\n              >\n            ).splice(key, 1);\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n\n    push(control: Controls[number]) {\n      this.setControl(this.controls.length, control);\n    },\n  } as IFormArray<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const enabledControlsMemo = createMemo(() =>\n    control.controls.filter((c) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      (control as IFormArray<Controls, Data>).controls.map(\n        (c) => c.rawValue\n      ) as unknown as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      enabledControlsMemo().map(\n        (c) => c.value\n      ) as unknown as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormArray<Controls, Data>;\n}\n"],"names":["AbstractControlInterface","isAbstractControl","object","AbstractControlContainerInterface","isAbstractControlContainer","isEqual","a","b","_isEqual","mergeObj","Object","defineProperties","getOwnPropertyDescriptors","bindOwner","fn","owner","getOwner","Error","runWithOwner","DEFAULT_SOURCE","propInitializer","initializationSignal","setInitializationSignal","createSignal","value","composeValidators","validators","Array","isArray","length","control","reduce","prev","curr","errors","controlId","createAbstractControlBase","store","untilInit","initOptions","setControl","selfIsPendingMemo","selfErrorsMemo","statusMemo","validatorMemo","base","id","Symbol","data","self","isValid","isPending","isDisabled","isTouched","isDirty","isReadonly","isSubmitted","isRequired","errorsStore","Map","pendingStore","Set","validatorStore","status","validator","markDisabled","input","markReadonly","markRequired","markDirty","markTouched","markSubmitted","markPending","options","newPendingStore","source","has","add","delete","produce","state","setErrors","existingStore","newErrorsStore","keys","set","patchErrors","newErrors","existingValue","get","k","err","entries","filter","v","fromEntries","setValidators","newValidatorsStore","newValidator","setData","key","initializer","createMemo","size","from","values","p","c","e","createComputed","on","rawValue","FormControlInterface","isFormControl","createFormControl","initValue","initComplete","initializeBase","storeConfig","setValue","createStore","disabled","touched","dirty","readonly","submitted","required","pending","createAbstractControlContainerBase","initializeAbstractControl","sizeMemo","childIsValidMemo","childIsDisabledMemo","childIsReadonlyMemo","childIsRequiredMemo","childIsPendingMemo","childIsTouchedMemo","childIsDirtyMemo","childIsSubmittedMemo","childrenAreValidMemo","childrenAreDisabledMemo","childrenAreReadonlyMemo","childrenAreRequiredMemo","childrenArePendingMemo","childrenAreTouchedMemo","childrenAreDirtyMemo","childrenAreSubmittedMemo","errorsMemo","childrenErrorsMemo","containerBase","children","areDisabled","child","areReadonly","areSubmitted","areValid","areRequired","arePending","areTouched","areDirty","batch","controls","forEach","deep","setControls","removeControl","keyOrControl","childControl","valueEntries","val","patchValue","entryValue","allControlsMemo","nonDisabledControlsMemo","some","every","FormGroupInterface","isFormGroup","createFormGroup","initControls","rawValueMemo","valueMemo","newControl","allControlEntriesMemo","enabledControlEntriesMemo","map","FormArrayInterface","isFormArray","createFormArray","splice","push","enabledControlsMemo"],"mappings":"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"}